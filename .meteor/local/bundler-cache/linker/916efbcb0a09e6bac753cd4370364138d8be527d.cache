[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar WebApp = Package.webapp.WebApp;\nvar main = Package.webapp.main;\nvar WebAppInternals = Package.webapp.WebAppInternals;\nvar RoutePolicy = Package.routepolicy.RoutePolicy;\nvar _ = Package.underscore._;\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////\n//                                                                                 //\n// packages/appcache/appcache-server.js                                            //\n//                                                                                 //\n/////////////////////////////////////////////////////////////////////////////////////\n                                                                                   //\nvar crypto = Npm.require('crypto');\nvar fs = Npm.require('fs');\nvar path = Npm.require('path');\n\nvar _disableSizeCheck = false;\n\nMeteor.AppCache = {\n  config: function (options) {\n    _.each(options, function (value, option) {\n      if (option === 'browsers') {\n        disabledBrowsers = {};\n        _.each(value, function (browser) {\n          disabledBrowsers[browser] = false;\n        });\n      }\n      else if (option === 'onlineOnly') {\n        _.each(value, function (urlPrefix) {\n          RoutePolicy.declare(urlPrefix, 'static-online');\n        });\n      }\n      // option to suppress warnings for tests.\n      else if (option === '_disableSizeCheck') {\n        _disableSizeCheck = value;\n      }\n      else if (value === false) {\n        disabledBrowsers[option] = true;\n      }\n      else if (value === true) {\n        disabledBrowsers[option] = false;\n      } else {\n        throw new Error('Invalid AppCache config option: ' + option);\n      }\n    });\n  }\n};\n\nvar disabledBrowsers = {};\nvar browserDisabled = function (request) {\n  return disabledBrowsers[request.browser.name];\n};\n\nWebApp.addHtmlAttributeHook(function (request) {\n  if (browserDisabled(request))\n    return null;\n  else\n    return { manifest: \"/app.manifest\" };\n});\n\nWebApp.connectHandlers.use(function (req, res, next) {\n  if (req.url !== '/app.manifest') {\n    return next();\n  }\n\n  // Browsers will get confused if we unconditionally serve the\n  // manifest and then disable the app cache for that browser.  If\n  // the app cache had previously been enabled for a browser, it\n  // will continue to fetch the manifest as long as it's available,\n  // even if we now are not including the manifest attribute in the\n  // app HTML.  (Firefox for example will continue to display \"this\n  // website is asking to store data on your computer for offline\n  // use\").  Returning a 404 gets the browser to really turn off the\n  // app cache.\n\n  if (browserDisabled(WebApp.categorizeRequest(req))) {\n    res.writeHead(404);\n    res.end();\n    return;\n  }\n\n  var manifest = \"CACHE MANIFEST\\n\\n\";\n\n  // After the browser has downloaded the app files from the server and\n  // has populated the browser's application cache, the browser will\n  // *only* connect to the server and reload the application if the\n  // *contents* of the app manifest file has changed.\n  //\n  // So to ensure that the client updates if client resources change,\n  // include a hash of client resources in the manifest.\n\n  manifest += \"# \" + WebApp.clientHash() + \"\\n\";\n\n  // When using the autoupdate package, also include\n  // AUTOUPDATE_VERSION.  Otherwise the client will get into an\n  // infinite loop of reloads when the browser doesn't fetch the new\n  // app HTML which contains the new version, and autoupdate will\n  // reload again trying to get the new code.\n\n  if (Package.autoupdate) {\n    var version = Package.autoupdate.Autoupdate.autoupdateVersion;\n    if (version !== WebApp.clientHash())\n      manifest += \"# \" + version + \"\\n\";\n  }\n\n  manifest += \"\\n\";\n\n  manifest += \"CACHE:\" + \"\\n\";\n  manifest += \"/\" + \"\\n\";\n  _.each(WebApp.clientPrograms[WebApp.defaultArch].manifest, function (resource) {\n    if (resource.where === 'client' &&\n        ! RoutePolicy.classify(resource.url)) {\n      manifest += resource.url;\n      // If the resource is not already cacheable (has a query\n      // parameter, presumably with a hash or version of some sort),\n      // put a version with a hash in the cache.\n      //\n      // Avoid putting a non-cacheable asset into the cache, otherwise\n      // the user can't modify the asset until the cache headers\n      // expire.\n      if (!resource.cacheable)\n        manifest += \"?\" + resource.hash;\n\n      manifest += \"\\n\";\n    }\n  });\n  manifest += \"\\n\";\n\n  manifest += \"FALLBACK:\\n\";\n  manifest += \"/ /\" + \"\\n\";\n  // Add a fallback entry for each uncacheable asset we added above.\n  //\n  // This means requests for the bare url (/image.png instead of\n  // /image.png?hash) will work offline. Online, however, the browser\n  // will send a request to the server. Users can remove this extra\n  // request to the server and have the asset served from cache by\n  // specifying the full URL with hash in their code (manually, with\n  // some sort of URL rewriting helper)\n  _.each(WebApp.clientPrograms[WebApp.defaultArch].manifest, function (resource) {\n    if (resource.where === 'client' &&\n        ! RoutePolicy.classify(resource.url) &&\n        !resource.cacheable) {\n      manifest += resource.url + \" \" + resource.url +\n        \"?\" + resource.hash + \"\\n\";\n    }\n  });\n\n  manifest += \"\\n\";\n\n  manifest += \"NETWORK:\\n\";\n  // TODO adding the manifest file to NETWORK should be unnecessary?\n  // Want more testing to be sure.\n  manifest += \"/app.manifest\" + \"\\n\";\n  _.each(\n    [].concat(\n      RoutePolicy.urlPrefixesFor('network'),\n      RoutePolicy.urlPrefixesFor('static-online')\n    ),\n    function (urlPrefix) {\n      manifest += urlPrefix + \"\\n\";\n    }\n  );\n  manifest += \"*\" + \"\\n\";\n\n  // content length needs to be based on bytes\n  var body = new Buffer(manifest);\n\n  res.setHeader('Content-Type', 'text/cache-manifest');\n  res.setHeader('Content-Length', body.length);\n  return res.end(body);\n});\n\nvar sizeCheck = function () {\n  var totalSize = 0;\n  _.each(WebApp.clientPrograms[WebApp.defaultArch].manifest, function (resource) {\n    if (resource.where === 'client' &&\n        ! RoutePolicy.classify(resource.url)) {\n      totalSize += resource.size;\n    }\n  });\n  if (totalSize > 5 * 1024 * 1024) {\n    Meteor._debug(\n      \"** You are using the appcache package but the total size of the\\n\" +\n      \"** cached resources is \" +\n      (totalSize / 1024 / 1024).toFixed(1) + \"MB.\\n\" +\n      \"**\\n\" +\n      \"** This is over the recommended maximum of 5 MB and may break your\\n\" +\n      \"** app in some browsers! See http://docs.meteor.com/#appcache\\n\" +\n      \"** for more information and fixes.\\n\"\n    );\n  }\n};\n\n// Run the size check after user code has had a chance to run. That way,\n// the size check can take into account files that the user does not\n// want cached. Otherwise, the size check warning will still print even\n// if the user excludes their large files with\n// `Meteor.AppCache.config({onlineOnly: files})`.\nMeteor.startup(function () {\n  if (! _disableSizeCheck)\n    sizeCheck();\n});\n\n/////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage.appcache = {};\n\n})();\n","servePath":"/packages/appcache.js","sourceMap":{"version":3,"sources":["/packages/appcache/appcache-server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/packages/appcache.js","sourcesContent":["var crypto = Npm.require('crypto');\nvar fs = Npm.require('fs');\nvar path = Npm.require('path');\n\nvar _disableSizeCheck = false;\n\nMeteor.AppCache = {\n  config: function (options) {\n    _.each(options, function (value, option) {\n      if (option === 'browsers') {\n        disabledBrowsers = {};\n        _.each(value, function (browser) {\n          disabledBrowsers[browser] = false;\n        });\n      }\n      else if (option === 'onlineOnly') {\n        _.each(value, function (urlPrefix) {\n          RoutePolicy.declare(urlPrefix, 'static-online');\n        });\n      }\n      // option to suppress warnings for tests.\n      else if (option === '_disableSizeCheck') {\n        _disableSizeCheck = value;\n      }\n      else if (value === false) {\n        disabledBrowsers[option] = true;\n      }\n      else if (value === true) {\n        disabledBrowsers[option] = false;\n      } else {\n        throw new Error('Invalid AppCache config option: ' + option);\n      }\n    });\n  }\n};\n\nvar disabledBrowsers = {};\nvar browserDisabled = function (request) {\n  return disabledBrowsers[request.browser.name];\n};\n\nWebApp.addHtmlAttributeHook(function (request) {\n  if (browserDisabled(request))\n    return null;\n  else\n    return { manifest: \"/app.manifest\" };\n});\n\nWebApp.connectHandlers.use(function (req, res, next) {\n  if (req.url !== '/app.manifest') {\n    return next();\n  }\n\n  // Browsers will get confused if we unconditionally serve the\n  // manifest and then disable the app cache for that browser.  If\n  // the app cache had previously been enabled for a browser, it\n  // will continue to fetch the manifest as long as it's available,\n  // even if we now are not including the manifest attribute in the\n  // app HTML.  (Firefox for example will continue to display \"this\n  // website is asking to store data on your computer for offline\n  // use\").  Returning a 404 gets the browser to really turn off the\n  // app cache.\n\n  if (browserDisabled(WebApp.categorizeRequest(req))) {\n    res.writeHead(404);\n    res.end();\n    return;\n  }\n\n  var manifest = \"CACHE MANIFEST\\n\\n\";\n\n  // After the browser has downloaded the app files from the server and\n  // has populated the browser's application cache, the browser will\n  // *only* connect to the server and reload the application if the\n  // *contents* of the app manifest file has changed.\n  //\n  // So to ensure that the client updates if client resources change,\n  // include a hash of client resources in the manifest.\n\n  manifest += \"# \" + WebApp.clientHash() + \"\\n\";\n\n  // When using the autoupdate package, also include\n  // AUTOUPDATE_VERSION.  Otherwise the client will get into an\n  // infinite loop of reloads when the browser doesn't fetch the new\n  // app HTML which contains the new version, and autoupdate will\n  // reload again trying to get the new code.\n\n  if (Package.autoupdate) {\n    var version = Package.autoupdate.Autoupdate.autoupdateVersion;\n    if (version !== WebApp.clientHash())\n      manifest += \"# \" + version + \"\\n\";\n  }\n\n  manifest += \"\\n\";\n\n  manifest += \"CACHE:\" + \"\\n\";\n  manifest += \"/\" + \"\\n\";\n  _.each(WebApp.clientPrograms[WebApp.defaultArch].manifest, function (resource) {\n    if (resource.where === 'client' &&\n        ! RoutePolicy.classify(resource.url)) {\n      manifest += resource.url;\n      // If the resource is not already cacheable (has a query\n      // parameter, presumably with a hash or version of some sort),\n      // put a version with a hash in the cache.\n      //\n      // Avoid putting a non-cacheable asset into the cache, otherwise\n      // the user can't modify the asset until the cache headers\n      // expire.\n      if (!resource.cacheable)\n        manifest += \"?\" + resource.hash;\n\n      manifest += \"\\n\";\n    }\n  });\n  manifest += \"\\n\";\n\n  manifest += \"FALLBACK:\\n\";\n  manifest += \"/ /\" + \"\\n\";\n  // Add a fallback entry for each uncacheable asset we added above.\n  //\n  // This means requests for the bare url (/image.png instead of\n  // /image.png?hash) will work offline. Online, however, the browser\n  // will send a request to the server. Users can remove this extra\n  // request to the server and have the asset served from cache by\n  // specifying the full URL with hash in their code (manually, with\n  // some sort of URL rewriting helper)\n  _.each(WebApp.clientPrograms[WebApp.defaultArch].manifest, function (resource) {\n    if (resource.where === 'client' &&\n        ! RoutePolicy.classify(resource.url) &&\n        !resource.cacheable) {\n      manifest += resource.url + \" \" + resource.url +\n        \"?\" + resource.hash + \"\\n\";\n    }\n  });\n\n  manifest += \"\\n\";\n\n  manifest += \"NETWORK:\\n\";\n  // TODO adding the manifest file to NETWORK should be unnecessary?\n  // Want more testing to be sure.\n  manifest += \"/app.manifest\" + \"\\n\";\n  _.each(\n    [].concat(\n      RoutePolicy.urlPrefixesFor('network'),\n      RoutePolicy.urlPrefixesFor('static-online')\n    ),\n    function (urlPrefix) {\n      manifest += urlPrefix + \"\\n\";\n    }\n  );\n  manifest += \"*\" + \"\\n\";\n\n  // content length needs to be based on bytes\n  var body = new Buffer(manifest);\n\n  res.setHeader('Content-Type', 'text/cache-manifest');\n  res.setHeader('Content-Length', body.length);\n  return res.end(body);\n});\n\nvar sizeCheck = function () {\n  var totalSize = 0;\n  _.each(WebApp.clientPrograms[WebApp.defaultArch].manifest, function (resource) {\n    if (resource.where === 'client' &&\n        ! RoutePolicy.classify(resource.url)) {\n      totalSize += resource.size;\n    }\n  });\n  if (totalSize > 5 * 1024 * 1024) {\n    Meteor._debug(\n      \"** You are using the appcache package but the total size of the\\n\" +\n      \"** cached resources is \" +\n      (totalSize / 1024 / 1024).toFixed(1) + \"MB.\\n\" +\n      \"**\\n\" +\n      \"** This is over the recommended maximum of 5 MB and may break your\\n\" +\n      \"** app in some browsers! See http://docs.meteor.com/#appcache\\n\" +\n      \"** for more information and fixes.\\n\"\n    );\n  }\n};\n\n// Run the size check after user code has had a chance to run. That way,\n// the size check can take into account files that the user does not\n// want cached. Otherwise, the size check warning will still print even\n// if the user excludes their large files with\n// `Meteor.AppCache.config({onlineOnly: files})`.\nMeteor.startup(function () {\n  if (! _disableSizeCheck)\n    sizeCheck();\n});\n"]}}]