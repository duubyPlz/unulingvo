{"version":3,"sources":["meteor://ðŸ’»app/packages/ground_db/groundDB.server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/packages/ground_db.js","sourcesContent":["/* global _groundDbConstructor:true */\n/*\n\n\nTODO:\n  `Meteor.default_server` - `Meteor.server`\n\n*/\n///////////////////////////////// TEST SCOPE ///////////////////////////////////\n\nMeteor.server = Meteor.server || Meteor.default_server; // jshint ignore:line\n\n//////////////////////////////// GROUND DATABASE ///////////////////////////////\n\n_groundDbConstructor = function(collection, options) { // jshint ignore:line\n  var self;\n  // XXX: Write the grounddb constructor\n\n\n  // // This is the basic interface allowing users easily access for handling\n  // // method calls, this.super() is the super and this.collection is self\n  // // TODO: Remove this section to the README\n  // self.conflictHandlers = (options && options.conflictHandlers)?\n  //       options.conflictHandlers: {\n  //   'insert': function(doc) {\n  //     //console.log('insert');\n  //     //console.log(doc);\n  //     this.super(doc);\n  //   },\n  //   'update': function(id, modifier) {\n  //     //console.log('update');\n  //     //console.log(id);\n  //     //console.log(modifier);\n  //     this.super(id, modifier);\n  //   },\n  //   'remove': function(id) {\n  //     //console.log('remove');\n  //     //console.log(id);\n  //     this.super(id);\n  //   }\n  // };\n\n  // // Create overwrite interface\n  // _.each(['insert', 'update', 'remove'], function(name) {\n  //   // TODO: init default conflict handlers\n  //   //self.conflictHandlers[name] = function() {\n  //   //  this.super.apply(this, arguments);\n  //   //};\n\n  //   // Save super\n  //   var _super = Meteor.default_server.method_handlers['/'+self.name+'/'+name];\n  //   // Overwrite\n  //   Meteor.default_server.method_handlers['/'+self.name+'/'+name] = function() {\n  //     var _this = this;\n  //     _this.collection = self;\n  //     _this.super = _super;\n  //     // Call the conflicthandlers\n  //     self.conflictHandlers[name].apply(_this, arguments);\n  //   };\n  // });\n\n  return self;\n};\n\n\n// Global helper for applying grounddb on a collection\nGround.Collection = function(name, options) {\n  var self;\n  // Inheritance Meteor Collection can be set by options.collection\n  // Accepts smart collections by Arunoda Susiripala\n  // Check if user used the \"new\" keyword\n\n\n  // Make sure we got some options\n  options = options || {};\n\n  // Either name is a Meteor collection or we create a new Meteor collection\n  if (name instanceof _groundUtil.Collection) {\n    self = name;\n  } else {\n    self = new _groundUtil.Collection(name, options);\n  }\n\n  // Throw an error if something went wrong\n  if (!(self instanceof _groundUtil.Collection)) {\n    throw new Error('Ground.Collection expected a Mongo.Collection');\n  }\n\n  // Add grounddb to the collection, circular reference since self is\n  // grounddb.collection\n  self.grounddb = new _groundDbConstructor(self, options);\n\n  // Return grounded collection - We dont return this eg if it was an instance\n  // of Ground.Collection\n  return self;\n};\n\n////////////////////////// TIMESTAMP CONFLICTHANDLER ///////////////////////////\n\n// TODO:\n// When clients make changes the server should track the documents from the\n// clients to see if the changes are new or old changes.\n// This could be done in several ways.\n// Either by versions or server timestamps - both could work.\n//\n// Conflicting overview:\n// We could cut it down to comparing two documents and keep / broadcast the\n// winning document.\n//\n// conflictHandler = function(clientDoc, serverDoc) { return serverDoc; }\n//\n//\n// There should be found a way of registrating deleted documents - eg. by having\n// a flag set 'active' all nonactive documents should then be removed from\n// published documents.\n//\n// This could be a standalone package since it would introduce conflict\n// handling in generel\n//\n// Regz. RaiX\n"]}