{"version":3,"sources":["meteor://ðŸ’»app/packages/ground_localstorage/client.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6G","file":"/packages/ground_localstorage.js","sourcesContent":["// This function will test localstorage to see if its actually available and\n// working.\nvar _getLocalStorage = function() {\n\n  // Set storage to localStorage - if test fails storage is set to null\n  var storage = window.localStorage;\n\n  // We initialize the fail flag defaulting to true\n  var fail = true;\n\n  // In the test we test the localstorage api setItem/getItem/removeItem this\n  // uid will hopefully prevent any overwriting of existing data\n  var uid = Random.id();\n\n  try {\n    // Use the setItem api\n    storage.setItem(uid, uid);\n    // Test the getItem api and check if the value could be set and retrieved\n    fail = (storage.getItem(uid) !== uid);\n    // Test removeItem and clean up the test data\n    storage.removeItem(uid);\n\n    // If the test failed then set the storage to null\n    if (fail) {\n      storage = null;\n    }\n\n  } catch(e) {\n    // Noop, cant do much about it\n  }\n\n  // Return the tested localstorage\n  return storage;\n};\n\n// Get storage if available\nvar _storage = _getLocalStorage();\n\n\n// Check to see if we got any localstorage to add\nif (_storage) {\n\n  // Create a namespace to track storage name spacing\n  var _localStorageNS = {};\n\n  // Create a noop function\n  var noop = function() {};\n\n  // Prefix convention\n  var _prefix = function(name) {\n    return '_storage.' + name;\n  };\n\n  // Prefix database\n  var _prefixDatabase = function(name) {\n    return _prefix(name) + '.db.';\n  };\n\n  // Prefix database record\n  var _prefixDatabaseRecord = function(name) {\n    return _prefix(name) + '.record';\n  };\n\n  // Helper getting and updating the table record\n  var _setTableRecord = function(SAInstance, migrationCallback) {\n\n    // Database record name in localstorage\n    var recordName = _prefixDatabaseRecord(SAInstance.name);\n\n    // Get the database record\n    var oldRecordString = _storage.getItem(recordName);\n\n    // Set the default empty record object\n    var record = {};\n\n    try {\n\n      // Get old record object\n      record = oldRecordString && EJSON.parse(oldRecordString) || {};\n\n    } catch(err) {\n      // Noop, cant do much about it, we assume that data is lost\n    }\n\n    // Set new version helper\n    var newVersion = SAInstance.version;\n\n    // Set old version helper\n    var oldVersion = record.version ||Â 1.0;\n\n    // Update the record\n    record.version = SAInstance.version;\n\n    try {\n\n      // Create new record as string\n      var newRecordString = EJSON.stringify(record);\n\n      // Store the new record\n      _storage.setItem(recordName, newRecordString);\n\n    } catch(err) {\n      // Noop, cant do much here\n    }\n\n    migrationCallback.call(SAInstance, {\n      version: oldVersion\n    }, {\n      version: newVersion\n    });\n  };\n\n  // Yeah, got it - add the api to the Storage global\n  Store.localStorage = function(options) {\n    var self = this;\n\n    if (!(self instanceof Store.localStorage)) {\n      return new Store.localStorage(self.name);\n    }\n\n    // Inheritance EventEmitter\n    self.eventemitter = new EventEmitter();\n\n    // Make sure options is at least an empty object\n    options = options || {};\n\n    // Set the name on the instance\n    self.name = options.name;\n\n    // Check to see if the storage is already defined\n    if (_localStorageNS[self.name]) {\n      throw new Error('Storage.localStorage \"' + self.name + '\" is already in use');\n    }\n\n    // Make sure that the user dont use '.db.'\n    if (/\\.db\\./.test(self.name)) {\n      throw new Error('Storage.localStorage \"' + self.name + '\" contains \".db.\" this is not allowed');\n    }\n\n    // Set the size of db 0 === disable quota\n    // TODO: Implement\n    self.size = options.size || 0;\n\n    // Set version - if this is bumped then the data is cleared pr. default\n    // migration\n    self.version = options.version ||Â 1.0;\n\n    // Set migration function\n    var migrationFunction = options.migration || function(oldRecord, newRecord) {\n\n      // Check storage versions\n      if (oldRecord.version !== newRecord.version) {\n        // We allow the user to customize a migration algoritme but here we just\n        // clear the storage if versions mismatch\n        self.clear(noop);\n      }\n    };\n\n    // Store the instance\n    _localStorageNS[self.name] = self;\n\n\n    // Set the table record, at the moment this is only handling the version\n    _setTableRecord(self, migrationFunction);\n\n  };\n\n  // Simple helper to return the storage type name\n  Store.localStorage.prototype.typeName = function() {\n    return 'localStorage';\n  };\n\n  Store.localStorage.prototype.prefix = function() {\n    var self = this;\n    return _prefixDatabase(self.name);\n  };\n\n  Store.localStorage.prototype.getPrefixedId = function(name) {\n    var self = this;\n    return self.prefix() + name;\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  // WRAP LOCALSTORAGE API\n  //////////////////////////////////////////////////////////////////////////////\n\n  Store.localStorage.prototype.getItem = function(name, callback) {\n    var self = this;\n\n    // Check if callback is function\n    if (typeof callback !== 'function') {\n      throw new Error('Storage.localStorage.getItem require a callback function');\n    }\n\n    try {\n\n      // Get the string value\n      var jsonObj = _storage.getItem(self.getPrefixedId(name));\n\n      // Try to return the object of the parsed string\n      callback(null, jsonObj && EJSON.parse(jsonObj) || jsonObj);\n\n    } catch(err) {\n      // Callback with error\n      callback(err);\n\n    }\n\n  };\n\n  Store.localStorage.prototype.setItem = function(name, obj, callback) {\n    var self = this;\n\n    // Check if callback is function\n    if (typeof callback !== 'function') {\n      throw new Error('Storage.localStorage.setItem require a callback function');\n    }\n\n    try {\n\n      // Stringify the object\n      var jsonObj = EJSON.stringify(obj);\n\n      // Try to set the stringified object\n      callback(null, _storage.setItem(self.getPrefixedId(name), jsonObj));\n\n    } catch(err) {\n\n      // Callback with error\n      callback(err);\n\n    }\n  };\n\n  Store.localStorage.prototype.removeItem = function(name, callback) {\n    var self = this;\n\n    // Check if callback is function\n    if (typeof callback !== 'function') {\n      throw new Error('Storage.localStorage.removeItem require a callback function');\n    }\n\n    try {\n\n      // Try to remove the item\n      callback(null, _storage.removeItem(self.getPrefixedId(name)));\n\n    } catch(err) {\n\n      // callback with error\n      callback(err);\n\n    }\n  };\n\n  Store.localStorage.prototype.clear = function(callback) {\n    var self = this;\n\n    // Check if callback is function\n    if (typeof callback !== 'function') {\n      throw new Error('Storage.localStorage.clear require a callback function');\n    }\n\n    try {\n\n      // Find all relevant keys for this storage\n      self.keys(function(err, keys) {\n        if (err) {\n\n          // On error we just callback\n          callback(err);\n\n        } else {\n\n          // Iterate over keys and removing them one by one\n          for (var i=0; i < keys.length; i++) {\n            self.removeItem(keys[i], noop);\n          }\n\n          // Callback\n          callback(null, keys.length);\n        }\n      });\n\n    } catch(err) {\n\n      // callback with error\n      callback(err);\n\n    }\n  };\n\n  Store.localStorage.prototype.keys = function(callback) {\n    var self = this;\n\n    // Check if callback is function\n    if (typeof callback !== 'function') {\n      throw new Error('Storage.localStorage.keys require a callback function');\n    }\n\n    // Result to return\n    var result = [];\n\n    try {\n\n      // Create the prefix test\n      var regex = new RegExp('^' + self.prefix());\n\n      for (var i = 0; i < _storage.length; i++) {\n\n        // Test if the key is relevant to this store\n        if (regex.test(_storage.key(i))) {\n          // Add the name\n          result.push(_storage.key(i).replace(regex, ''));\n        }\n      }\n\n      // Return the result\n      callback(null, result);\n\n    } catch(err) {\n\n      // callback with error\n      callback(err);\n\n    }\n  };\n\n  Store.localStorage.prototype.length = function(callback) {\n    var self = this;\n\n    // Check if callback is function\n    if (typeof callback !== 'function') {\n      throw new Error('Storage.localStorage.length require a callback function');\n    }\n\n    try {\n\n      // Get the keys\n      self.keys(function(error, keys) {\n\n        // Return the length\n        callback(error, keys && keys.length || null);\n\n      });\n\n    } catch(err) {\n\n      // callback with error\n      callback(err);\n\n    }\n  };\n\n  Store.localStorage.prototype.toObject = function(callback) {\n    var self = this;\n\n    // Check if callback is function\n    if (typeof callback !== 'function') {\n      throw new Error('Storage.localStorage.toObject require a callback function');\n    }\n\n    // Result to return\n    var result = {};\n\n    try {\n\n      // Create the prefix test\n      var regex = new RegExp('^' + self.prefix());\n\n      for (var i = 0; i < _storage.length; i++) {\n        // Helper\n        var key = _storage.key(i);\n\n        // Test if the key is relevant to this store\n        if (regex.test(key)) {\n          try {\n\n            // Get the string value\n            var jsonObj = _storage.getItem(key);\n\n            // Try to return the object of the parsed string\n            result[key.replace(regex, '')] = jsonObj && EJSON.parse(jsonObj) || jsonObj;\n\n          } catch(err) {\n            // NOOP\n          }\n        }\n\n      }\n\n      // Return the result\n      callback(null, result);\n\n    } catch(err) {\n\n      // callback with error\n      callback(err);\n\n    }\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  // WRAP EVENTEMITTER API\n  //////////////////////////////////////////////////////////////////////////////\n\n  // Wrap the Event Emitter Api \"on\"\n  Store.localStorage.prototype.on = function(/* arguments */) {\n    this.eventemitter.on.apply(this.eventemitter, _.toArray(arguments));\n  };\n\n  // Wrap the Event Emitter Api \"once\"\n  Store.localStorage.prototype.once = function(/* arguments */) {\n    this.eventemitter.once.apply(this.eventemitter, _.toArray(arguments));\n  };\n\n  // Wrap the Event Emitter Api \"off\"\n  Store.localStorage.prototype.off = function(/* arguments */) {\n    this.eventemitter.off.apply(this.eventemitter, _.toArray(arguments));\n  };\n\n  // Wrap the Event Emitter Api \"emit\"\n  Store.localStorage.prototype.emit = function(/* arguments */) {\n    this.eventemitter.emit.apply(this.eventemitter, _.toArray(arguments));\n  };\n\n\n  // Add api helpers\n  Store.localStorage.prototype.addListener = Store.localStorage.prototype.on;\n  Store.localStorage.prototype.removeListener = Store.localStorage.prototype.off;\n  Store.localStorage.prototype.removeAllListeners = Store.localStorage.prototype.off;\n\n  // Add jquery like helpers\n  Store.localStorage.prototype.one = Store.localStorage.prototype.once;\n  Store.localStorage.prototype.trigger = Store.localStorage.prototype.emit;\n\n\n\n  //////////////////////////////////////////////////////////////////////////////\n  // WRAP LOCALSTORAGE EVENTHANDLER\n  //////////////////////////////////////////////////////////////////////////////\n\n  // This will be a quick test to see if we have any relations to the data\n  var _prefixedByUs = new RegExp('^' + _prefix(''));\n\n  // Add event handlers\n  if (typeof window.addEventListener !== 'undefined') {\n      // Add support for multiple tabs\n      window.addEventListener('storage', function(e) {\n      // Data changed in another tab, it would have updated localstorage, I'm\n      // outdated so reload the tab and localstorage - but we test the prefix on the\n      // key - since we actually make writes in the localstorage feature test\n\n      // First of lets make sure that it was actually prefixed by us\n      if (e.key && _prefixedByUs.test(e.key)) {\n\n        // Okay, this looks familiar, now we try to lookup the storage instance\n        // to emit an event on...\n\n        // Remove the prefix\n        var noPrefix = e.key.replace(_prefixedByUs, '');\n\n        // So we know that the name dont contain suffix \".db.\"\n        var elements = noPrefix.split('.db.');\n\n        var storageName = elements.shift();\n\n        // Get the remaining key\n        var key = elements.join('.db.');\n\n        // Get the affected storage\n        var storageAdapter = _localStorageNS[storageName];\n\n        if (storageAdapter) {\n\n          // Emit the event on the storage\n          storageAdapter.emit('storage', {\n            key: key,\n            newValue: e.newValue && EJSON.parse(e.newValue) || e.newValue,\n            oldValue: e.oldValue && EJSON.parse(e.oldValue) || e.oldValue,\n            originalKey: e.key,\n            updatedAt: new Date(e.timeStamp),\n            url: e.url,\n            storage: storageAdapter\n          });\n        }\n\n      }\n\n    }, false);\n}\n\n}\n"]}